{"pageProps":{"slug":"floyds-algorithm","thread":null,"id":"floyds-algorithm","contentSource":"floyds-algorithm","tags":[{"slug":"linked-list","title":"Linked List","id":"linked-list"},{"id":"story","slug":"story","title":"Story"}],"category":{"slug":"dsa","title":"DSA","id":"dsa"},"banner":"https://firebasestorage.googleapis.com/v0/b/zealot97-c70d5.appspot.com/o/tortoise-and-the-hare.jpg?alt=media&token=0652a524-0e27-418d-970c-9c037592187e","isPublished":true,"title":"Floyd's algorithm for loop detection in linked list","subtitle":"Also called tortoise 🐢 and hare algorithm 🐇.... makes me remember that story on the two in which hare lost","publishedAt":1626458575850,"createdAt":1626451966091,"updatedAt":1626458575850,"content":"There are a few questions on linked list that can harness Floyd's algorithm. One of them being [this](https://leetcode.com/problems/linked-list-cycle) on leetcode.\n\n### Story nostalgia\n\nThis question made me remember the story we heard in our childhood. Of a bunny🐇 and a tortoise🐢 race. Who won in that.... the tortoise. Why? Because the bunny slept💤.\n\nIn the following algorithm, bunny wins the race🏁. Because he learnt his lesson and didn't sleep this time. But eventually both lose because they get stuck in a loop...\n\nEnough with the story.\n\n### Brute way 💪\n\nThe general way that comes into mind while loop detection in linked list is the method to store all node references in a single pass within a hash function and, if during iteration, we encounter a node already existing in the hash... the loop is found. We can store this reference for the application and for the usage we desire.\n\n```java\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        Set<ListNode> map = new HashSet<>();\n        while(head!=null){\n            map.add(head);\n            if(head.next != null && map.contains(head.next)) return true;\n            head = head.next;\n        }\n        return false;\n    }\n}\n```\n\nBut it's a relatively expensive w.r.t. the algorithm we are gonna discuss, in terms of memory, the complexity being `O(n)`.\n\n### Memory optimized approach 🤔\n\nA trick to reduce memory complexity is to use two pointers. A `fast` and `slow` one. `fast` moves two nodes at a time. `slow` moves across one.\n\nResults first, maths later. In order to detect the loop, we first allow the two pointers to meet. With the speed of `fast` twice to that of `slow`. `slow` moves one node ahead at a time (duh....).\n\nOnce they meet we once again start the iteration. For `slow` we start from the beginning of linked list and for the `fast` pointer we start from wherever it is. But both of them move one node at a time (Hare doesn't have infinite energy after all, he's tired... or maybe he's getting pompous, again). Now .... when these two meet during the iteration we get our **looping point**. \n\nSince in the question we don't need the looping point, we can allow the pointers to meet once and break out.\n\n```java\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        if(head == null || head.next == null) return false; // not possible\n        \n        ListNode slow=head, fast = head.next;\n        while(fast!=slow){\n            if(fast == null || null == fast.next) return false; // no cycle\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        return true;\n    }\n}\n```\nTime complexity is along some constant factor of `O(n)` which is effectively the same. But memory complexity is now `O(1)`.\n\n### Finding looping point - maths here🤩\n\nPlease note the distances are in clockwise direction.\n\nLet's assume that linked list is as in diagram above. *A* is starting point. *B* is point where loop starts. *C* is point where the two pointers meet for the first time. *a* is distance from *A* to *B*. *b* is from *B* to *C*. *c* for *C* to *B*.\n\nNow when the two pointers to meet for the first time, distance moved by `slow` is `a+b` and by `fast` is `a+b+c+b`. Then...\n```\n(a+b)*2=a+b+c+b => a=c\n```\n\nTherefore after `fast` and `slow` meet, if we move both `slow`(from _**start**_ pt) and `fast`(from _**wherever it is**_) with same speed(we can use **1 node/jump**) and then allow them to meet, we can find the **looping point**.\n"},"__N_SSG":true}