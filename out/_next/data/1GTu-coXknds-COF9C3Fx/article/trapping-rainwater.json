{"pageProps":{"isPublished":true,"title":"Trapping rainwater","tags":[{"id":"dynamic-programming","slug":"dynamic-programming","title":"Dynamic programming"},{"title":"Two-pointer method","id":"two-pointer","slug":"two-pointer"}],"category":{"title":"DSA","id":"dsa","slug":"dsa"},"contentSource":"trapping-rainwater","publishedAt":1626539408627,"subtitle":"We shall do more of it in real life as well","id":"trapping-rainwater","createdAt":1626539359239,"thread":null,"slug":"trapping-rainwater","banner":"https://firebasestorage.googleapis.com/v0/b/zealot97-c70d5.appspot.com/o/rainwatertrap.png?alt=media&token=ff15926f-1eef-4958-9d01-ecdbac7b1a15","updatedAt":1626539408627,"content":"# Trapping rainwater\n\n### We shall do more of it in real life as well.\n\nWell, this question is a real easy one. On leetcode it's [numbered at 42](https://leetcode.com/problems/trapping-rain-water/description).\n\nDespite of knowing the solution by heart I messed up showcasing my solution in my Amazon interview. It is similar to [container with most water problem](https://leetcode.com/problems/container-with-most-water/description/) whom I mixed it up with😐. Or was it vice versa? See, even at the moment of writing this I am even confused.\n\nThe lesson was simple, \n> Don't jump to most optimal solutions in one go, especially during interviews when excitement is running high.\n\nThe solution is to calculate the maximum height amongst all elevations on both the sides for each elevation in the array. Since these maximums will prevent water runoff therefore they'll probably help in storing some water.\n\nThen we can pick the minimum amongst both, left and right height's and subtract the height of current elevation from it to determine the amount of rainwater stored for elevation at that index.\n\n![rain-water-trap](https://firebasestorage.googleapis.com/v0/b/zealot97-c70d5.appspot.com/o/rainwatertrap.png?alt=media&token=ff15926f-1eef-4958-9d01-ecdbac7b1a15)\n\nThe brute way to do this is to iterate over the array once and for each element calculate the maximum height on both sides. This'll run in `O(n^2)`. It's trivial and can easily be visualised. So I won't bother writing the code for this solution.\n\nOf course, we can use the _dynamic programming_ to store the recurring calculations of maximums for both left and right using a single pass from left to right and then from right to left. And then simply use it to calculate the result. In this case the time complexity is gonna be `O(n)` and memory complexity, `O(n)`.\n\nHere's my code,\n```java\nclass Solution {\n    public int trap(int[] height) {\n        if(height.length <3) return 0;\n        int wCollected = 0, left[] = new int[height.length], right[] = new int[height.length];\n        left[0] = height[0];\n        for(int i=1; i<height.length; i++){\n            left[i] = Integer.max(height[i], left[i-1]);\n        }\n        right[height.length-1] = height[height.length-1];\n        for(int i=height.length-2; i>=0; i--){\n            right[i] = Integer.max(height[i], right[i+1]);\n        }\n        for(int i=1; i<height.length; i++){\n            wCollected += Integer.min(left[i], right[i]) - height[i];\n        }\n        return wCollected;\n    }\n}\n```\n\nHowever, if we carefully observe the left and right height arrays we'll see that they follow a strictly increasing and decreasing order respectively. That's the trick for better space complexity. Hope it ticked you....\n\nLet's utilize it. For that we use _two pointer method_. \n\nWe'll use these pointers for indexing(call it `left` and `right`) as well as one more pair (call it `leftMax` and `rightMax`) to store the maximum height. \n\nIf the elevation at `left` is smaller than `right`, we calculate water collected in it based on max values as we did above and increment `left` by 1. Otherwise, we do the same for elevation on the `right` and decrement `right` by 1. If this difference is negative we don't add it to solution.\n\nAs we can see it works with memory complexity of `O(1)` and time complexity of `O(n)`.\n\nHere's my implementation of it,\n```java\nclass Solution {\n    public int trap(int[] hts) {\n        if(hts.length < 3) return 0;\n        int l, r, maxL, maxR;\n        l = 0;\n        r = hts.length-1;\n        maxL = hts[l]; maxR = hts[r];\n        int water = 0;\n        while(l<r){\n            if(maxL<maxR){\n                water += Integer.max(0, Integer.min(maxL, maxR)-hts[l]);\n                maxL = Integer.max(maxL, hts[++l]);\n            }else{\n                water += Integer.max(0, Integer.min(maxL, maxR)-hts[r]);\n                maxR = Integer.max(maxR, hts[--r]);\n            }\n        }\n        return water;\n    }\n}\n```\nHope it helps, 👋.\n"},"__N_SSG":true}